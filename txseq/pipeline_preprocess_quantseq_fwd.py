"""================================
Pipeline preprocess_quantseq_fed
================================

Overview
--------

This pipieline cuts adaptors from quantseq data according to the `Lexogen FAQ<https://faqs.lexogen.com/faq/what-is-the-adapter-sequence-i-need-to-use-for-t-1>`_:

"In general we can recommend using cutadapt (v.1.18) with the following parameters for read 1 trimming."

.. code::
    
    cutadapt -m 20 -O 20 -a "polyA=A{20}" -a "QUALITY=G{20}" -n 2 ${R1_raw} | \
    cutadapt -m 20 -O 3 --nextseq-trim=10 -a "r1adapter=A{18}AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=3;max_error_rate=0.100000" – | \
    cutadapt -m 20 -O 20 -g "r1adapter=AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=20" --discard-trimmed -o ${R1_trimmed} –


Configuration
-------------

The pipeline requires a configured :file:`preprocess_quantseq_fwd.yml` file.

Default configuration files can be generated by executing: ::

   txseq preprocess_quantseq_fwd config


Inputs
------

The pipeline requires the following inputs

#. fastqs.tsv: A text file containing the paths of the FASTQ files to be processed, one per line.


Requirements
------------

The following software is required:

#. `cutadapt <https://cutadapt.readthedocs.io/en/stable/>`_. 


Output files
------------

The pipeline produces the following outputs:

#. cutadapt processed FASTQ files: in the "cutadapt.dir" sub-folder.


Code
====

"""
from ruffus import *

import sys
import shutil
import os
from pathlib import Path
import glob


from cgatcore import experiment as E
from cgatcore import pipeline as P
from cgatcore import database as DB
import cgatcore.iotools as IOTools


# import local pipeline utility functions
import txseq.tasks as T

# ----------------------- < pipeline configuration > ------------------------ #

# Override function to collect config files
P.control.write_config_files = T.write_config_files

# load options from the yml file
P.parameters.HAVE_INITIALIZED = False
PARAMS = P.get_parameters(T.get_parameter_file(__file__))

# set the location of the code directory
PARAMS["txseq_code_dir"] = Path(__file__).parents[1]


# ---------------------- < specific pipeline tasks > ------------------------ #
    
# ########################################################################### #
# ################ (2) Quantitation of gene expression #################### #
# ########################################################################### #

# ---------------------- Salmon TPM calculation ----------------------------- #

def cutadapt_jobs():

    with open(PARAMS["fastqs"],"r") as fqs:
    
        for line in fqs:
        
            fq_path = line.strip()
        
            if fq_path == "":
                continue

            fq_out_path = os.path.join("cutadapt.dir",
                                os.path.basename(fq_path)) + ".sentinel"
                                

            yield([fq_path, fq_out_path])

@files(cutadapt_jobs)
def cutadapt(infile, sentinel):
    '''
    Run cutadapt on Lexogen quantseq FWD data
    '''
    
    t = T.setup(infile, sentinel, PARAMS,
                memory="12G",
                cpu=1)
    
    mktemp_template = "ctmp.cutadapt.XXXXXXXXXX"
    
    if PARAMS["trim"] != False:
        trim = '''trim_out=`mktemp -p . %(mktemp_template)s`;
                  cutadapt -l %(trim)s %(infile)s -o $trim_out &>> %(log_file)s;
                  ''' % dict(PARAMS, **t.var, **locals())
        trim_cleanup="rm $trim_out;"
    else:
        trim = "trim_out=%(infile)s;"
        trim_cleanup = ""

    # for some reason piping output between cutadapt commands doesn't work...
    statement = trim + '''cutadapt_out_a=`mktemp -p . %(mktemp_template)s`;
                   cutadapt_out_b=`mktemp -p . %(mktemp_template)s`;
                   cutadapt -m 20 -O 20 -a "polyA=A{20}" -a "QUALITY=G{20}" -n 2 $trim_out -o $cutadapt_out_a &>> %(log_file)s;
                   cutadapt -m 20 -O 3 --nextseq-trim=10 -a "r1adapter=A{18}AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=3;max_error_rate=0.100000" $cutadapt_out_a -o $cutadapt_out_b &>> %(log_file)s;
                   cutadapt -m 20 -O 20 -g "r1adapter=AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=20" --discard-trimmed $cutadapt_out_b -o %(out_file)s &>> %(log_file)s;
                   rm $cutadapt_out_a $cutadapt_out_b;
              ''' % dict(PARAMS, **t.var, **locals()) + trim_cleanup
              
    print(statement)

    P.run(statement, **t.resources)
    
    IOTools.touch_file(sentinel)





# --------------------- < generic pipeline tasks > -------------------------- #

@follows(cutadapt)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
