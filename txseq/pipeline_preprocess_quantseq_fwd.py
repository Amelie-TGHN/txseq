"""================================
Pipeline preprocess_quantseq_fed
================================

Overview
========

This pipieline cuts adaptors from quantseq data according to the `Lexogen FAQ<https://faqs.lexogen.com/faq/what-is-the-adapter-sequence-i-need-to-use-for-t-1>`_:

"In general we can recommend using cutadapt (v.1.18) with the following parameters for read 1 trimming."

.. code::
    
    cutadapt -m 20 -O 20 -a "polyA=A{20}" -a "QUALITY=G{20}" -n 2 ${R1_raw} | \
    cutadapt -m 20 -O 3 --nextseq-trim=10 -a "r1adapter=A{18}AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=3;max_error_rate=0.100000" – | \
    cutadapt -m 20 -O 20 -g "r1adapter=AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=20" --discard-trimmed -o ${R1_trimmed} –
    

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline_preprocess_quantseq_fwd.yml` file.

A default configuration file can be generated by executing:

   python <srcdir>/pipeline_preprocess_quantseq_fwd.py config


Inputs
------

1. FASTQ file list
^^^^^^^^^^^^^^^^^^

A text file containing the full paths to the FASTQ files to be processed, one per line. The file should not have a header line.


Requirements
------------

On top of the default CGAT setup, the pipeline requires the following
software to be in the path:

.. Add any additional external requirements such as 3rd party software
   or R modules below:

Requirements:

* cutadapt

Pipeline output
===============

A folder "cutadapt.dir" in which the output FASTQ files are written. They have the same names as the input files.

Glossary
========

.. glossary::


Code
====

"""
from ruffus import *

import sys
import shutil
import os
from pathlib import Path
import glob


from cgatcore import experiment as E
from cgatcore import pipeline as P
from cgatcore import database as DB
import cgatcore.iotools as IOTools


# import local pipeline utility functions
import txseq.tasks as T
import txseq.tasks.samples as samples

# ----------------------- < pipeline configuration > ------------------------ #

# Override function to collect config files
P.control.write_config_files = T.write_config_files

# load options from the yml file
P.parameters.HAVE_INITIALIZED = False
PARAMS = P.get_parameters(T.get_parameter_file(__file__))

# set the location of the code directory
PARAMS["txseq_code_dir"] = Path(__file__).parents[1]


# ---------------------- < specific pipeline tasks > ------------------------ #
    
# ########################################################################### #
# ################ (2) Quantitation of gene expression #################### #
# ########################################################################### #

# ---------------------- Salmon TPM calculation ----------------------------- #

def cutadapt_jobs():

    with open(PARAMS["fastqs"],"r") as fqs:
    
        for line in fqs:
        
            fq_path = line.strip()
        
            if fq_path == "":
                continue

            fq_out_path = os.path.join("cutadapt.dir",
                                os.path.basename(fq_path)) + ".sentinel"
                                

            yield([fq_path, fq_out_path])

@files(cutadapt_jobs)
def cutadapt(infile, sentinel):
    '''
    Run cutadapt on Lexogen quantseq FWD data
    '''
    
    t = T.setup(infile, sentinel, PARAMS,
                memory="12G",
                cpu=1)
    
    mktemp_template = "ctmp.cutadapt.XXXXXXXXXX"

    # for some reason piping output between cutadapt commands doesn't work...
    statement = '''cutadapt_out_a=`mktemp -p . %(mktemp_template)s`;
                   cutadapt_out_b=`mktemp -p . %(mktemp_template)s`;
                   cutadapt -m 20 -O 20 -a "polyA=A{20}" -a "QUALITY=G{20}" -n 2 %(infile)s -o $cutadapt_out_a &> %(log_file)s;
                   cutadapt -m 20 -O 3 --nextseq-trim=10 -a "r1adapter=A{18}AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=3;max_error_rate=0.100000" $cutadapt_out_a -o $cutadapt_out_b &>> %(log_file)s;
                   cutadapt -m 20 -O 20 -g "r1adapter=AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC;min_overlap=20" --discard-trimmed $cutadapt_out_b -o %(out_file)s &>> %(log_file)s;
                   rm $cutadapt_out_a $cutadapt_out_b;
              ''' % dict(PARAMS, **t.var, **locals())
              
    P.run(statement, **t.resources)
    
    IOTools.touch_file(sentinel)





# --------------------- < generic pipeline tasks > -------------------------- #

@follows(cutadapt)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
